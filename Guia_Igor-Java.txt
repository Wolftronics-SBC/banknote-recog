Roteiro para construir o projeto da aula:

1. A utilização do ADT Bundle (disponível em http://developer.android.com/sdk/index.html) facilita bastante as configurações.

2. Adicionar projeto do OpenCV no workspace. Criar novo projeto e colocar o projeto do OpenCV como library (Properties -> Android);

3. Carregamento do OpenCV é feito assíncronamente usando as classes OpenCVLoader e BaseLoaderCallback. O OpenCVLoader.initAsync é usado no onResume() para carregar o OpenCV dinamicamente. O BaseLoaderCallback é o ponto de retorno e a função onManagerConnected é chamada quando o OpenCVLoader identifica (ou não) a instalação do OpenCV.

4. É necessário adicionar um JavaCameraView no layout e colocar as permissões (disponíveis em http://docs.opencv.org/doc/tutorials/introduction/android_binary_package/dev_with_OCV_on_Android.html) no manifest. A classe CameraBridgeViewBase é usada para controlar o JavaCameraView e precisa ser habilitada no BaseLoaderCallback.

5. Para receber os frames a Activity deve implementar CvCameraViewListener2 e ser registrada no CameraBridgeViewBase usando setCvCameraViewListener. A função mais importante é onCameraFrame, que retorna um Mat contendo a imagem a ser mostrada na tela.

-------------------- Parte de C++ ------------------------

6. O NDK deve ser baixado (http://developer.android.com/tools/sdk/ndk/index.html) e configurado em Window->Preferences->Android->NDK. Os includes do OpenCV devem ser adicionados em Projeto->Properties->C++/General->Paths and Symbols e a configuração para compilar ao salvar é feita em Projeto->Properties->C++/Build, Aba Behavior. 

7. Para adicionar uma parte em C++ é só ir em Projeto->Android Tools->Add Native Part. Adicione o arquivo Application.mk com o seguinte conteúdo:

APP_PLATFORM := android-8
APP_STL := gnustl_static
APP_CPPFLAGS := -frtti -fexceptions
APP_ABI := armeabi-v7a

Adicione um include no Android.mk para incluir o OpenCV.mk . Pode ser legal também adicionar a biblioteca -llog em LOCAL_LDFLAGS.

8. Um método nativo em Java é declarado como

public native void ColorSegment(long addr)

e Mats são passados como long usando a função mat.getNativeObjAddr().

9. A função em C++ deverá ter o seguinte protótipo:

extern "C" JNIEXPORT (retorno) JNICALL Java_pacote_classe_metodo(JNIEnv* env, jobject _this, parâmetros).

A biblioteca é carregada usando System.loadLibrary("nome");

10. O acesso a pixels em Mat é feito usando a função template at, que recebe como argumento do template o tipo de dados da imagem. Se for uma imagem em níveis de cinza o tipo é uchar, se for colorida com 3 canais é Vec3b, se for com 4 canais é Vec4b. 


